package itstep.learning.asyncs;

import java.util.Random;

public class SyncDemo {
    private Random random ;
    private long time1 ;
    private long time2 ;
    public void run() {
        random = new Random() ;
        sum = 100 ;
        activeThreads = 12 ;
        time1 = System.nanoTime() ;
        for( int i = 0; i < 12; ++i ) {
            new Thread( this::plusPercent2 ).start() ;
        }
    }
    private double sum ;
    private Integer activeThreads ;
    private final Object activeThreadsLocker = new Object() ;
    private final Object locker = new Object() ;   // любой ссылочный тип имеет специальную область
    // памяти - критическую секцию - примитив синхронизации, сигнальный системный
    // элемент, который управляет остановкой и возобновлением потоков
    private void plusPercent() {
        synchronized( locker ) {   // вход в блок - "закрытие" секции если она открыта, либо ожидание ее открытыя
            double base = sum;     // чтение данных
            try {
                Thread.sleep(100 + random.nextInt(100));
            }
            catch (InterruptedException ignored) {
                System.err.println("Interruption");
            }
            double percent = 10;
            base *= 1 + percent / 100;
            sum = base;   // запись данных
        }  // конец синхроблока открывает секцию и следующий поток ее закрывает и начинает работать
        System.out.println( sum ) ;
    }
    private void plusPercent2() {
        try {  // это можно делать до транзакции - выносим за синхроблок
            Thread.sleep( 100 ) ;   //+ random.nextInt(100));
        }
        catch( InterruptedException ignored ) {
            System.err.println("Interruption");
        }
        double percent = 10 ;
        double base ;
        synchronized( locker ) {    // вход в блок - "закрытие" секции если она открыта, либо ожидание ее открытыя
            base = sum ;   // чтение данных
            base *= 1 + percent / 100 ;
            sum = base ;   // запись данных
        }  // конец синхроблока открывает секцию и следующий поток ее закрывает и начинает работать

        // System.out.println( sum ) ; - вывод общего ресурса, он может поменяться в процессе подготовки вывода
        System.out.println( base ) ;   // локальная переменная - у каждого потока своя
        // определяем последний ли
        // synchronized( activeThreads ) {  нельзя: Integer - immutable
        synchronized( activeThreadsLocker ) {
            activeThreads -= 1 ;   // меняет ссылку на объект, новый объект всегда "открытый"
            if( activeThreads == 0 ) onFinish() ;
        }
    }

    private void onFinish() {   // должен запуститься после всех потоков (после последнего)
        time2 = System.nanoTime() ;
        System.out.println( ( time2 - time1 ) / 1e9 ) ;
    }
}
/*
Синхронизация потоков

Модельная задача: Нацбанк публикует данные об инфляции за каждый месяц
Задача - рассчитать годовую инфляцию. Сложность - запросы на API долгие
и могут выполняться параллельно.
Математика:
(100 + 10%) + 20%  =?= (100 + 20%) + 10%
+10% == x1.1
(100x1.1)x1.2 =?= (100x1.2)x1.1 == 100x1.1x1.2
==> порядок "сложения" процентов произвольный
    это обосновывет возможность асинхронности

Проблема: разность во времени между операциями чтения и записи данных
Решение: создание "транзакции" на это время
 а) при помощи атомарных типов
 б) при помощи синхроблоков

Проблема: заключение всего тела потоковой функции в синхроблок
"выстраивает" их во времени, по-сути убирая параллельность
Решение: рефакторинг кода, уменьшение транзакции до минимально
возможного "расстояния"

!! Все обращения к общим ресурсам (глобальным переменным) должны ОБЯЗАТЕЛЬНО
   быть транзакциями, в т.ч. такие кажущиеся целостными выражения типа sum += 10

Задача: определить какой поток последний и вывести общее время работы
 а) используется коллективное ожидание (надо собирать массив потоков)
 б) вызывает отдельный метод - завершения


Задание: реализовать решение квадратного уравнения  ax^2 + bx + c = 0
1. расчет дискриминанта D = b^2 - 4ac  синхронно
2. расчет двух корней уравнения - параллельно
     если D >= 0 --> x1 = ( -b - sqrt(D) ) / 2a иначе "не существует" --> вывод
     если D >= 0 --> x2 = ( -b + sqrt(D) ) / 2a иначе "не существует" --> вывод
3. определить полное время работы (последний из методов выводит время)

                          ------x1---
схема выполнения:  --D--<
                          ------x2---
 */
